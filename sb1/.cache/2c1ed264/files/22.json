{"contents":"exports.__esModule = true;\nvar directive_js_1 = __fusereq(19);\nvar dom_js_1 = __fusereq(20);\nvar part_js_1 = __fusereq(21);\nvar template_instance_js_1 = __fusereq(25);\nvar template_result_js_1 = __fusereq(26);\nvar template_js_1 = __fusereq(27);\nexports.isPrimitive = value => {\n  return value === null || !(typeof value === 'object' || typeof value === 'function');\n};\nexports.isIterable = value => {\n  return Array.isArray(value) || !!(value && value[Symbol.iterator]);\n};\nclass AttributeCommitter {\n  constructor(element, name, strings) {\n    this.dirty = true;\n    this.element = element;\n    this.name = name;\n    this.strings = strings;\n    this.parts = [];\n    for (let i = 0; i < strings.length - 1; i++) {\n      this.parts[i] = this._createPart();\n    }\n  }\n  _createPart() {\n    return new AttributePart(this);\n  }\n  _getValue() {\n    const strings = this.strings;\n    const l = strings.length - 1;\n    let text = '';\n    for (let i = 0; i < l; i++) {\n      text += strings[i];\n      const part = this.parts[i];\n      if (part !== undefined) {\n        const v = part.value;\n        if (exports.isPrimitive(v) || !exports.isIterable(v)) {\n          text += typeof v === 'string' ? v : String(v);\n        } else {\n          for (const t of v) {\n            text += typeof t === 'string' ? t : String(t);\n          }\n        }\n      }\n    }\n    text += strings[l];\n    return text;\n  }\n  commit() {\n    if (this.dirty) {\n      this.dirty = false;\n      this.element.setAttribute(this.name, this._getValue());\n    }\n  }\n}\nexports.AttributeCommitter = AttributeCommitter;\nclass AttributePart {\n  constructor(committer) {\n    this.value = undefined;\n    this.committer = committer;\n  }\n  setValue(value) {\n    if (value !== part_js_1.noChange && (!exports.isPrimitive(value) || value !== this.value)) {\n      this.value = value;\n      if (!directive_js_1.isDirective(value)) {\n        this.committer.dirty = true;\n      }\n    }\n  }\n  commit() {\n    while (directive_js_1.isDirective(this.value)) {\n      const directive = this.value;\n      this.value = part_js_1.noChange;\n      directive(this);\n    }\n    if (this.value === part_js_1.noChange) {\n      return;\n    }\n    this.committer.commit();\n  }\n}\nexports.AttributePart = AttributePart;\nclass NodePart {\n  constructor(options) {\n    this.value = undefined;\n    this.__pendingValue = undefined;\n    this.options = options;\n  }\n  appendInto(container) {\n    this.startNode = container.appendChild(template_js_1.createMarker());\n    this.endNode = container.appendChild(template_js_1.createMarker());\n  }\n  insertAfterNode(ref) {\n    this.startNode = ref;\n    this.endNode = ref.nextSibling;\n  }\n  appendIntoPart(part) {\n    part.__insert(this.startNode = template_js_1.createMarker());\n    part.__insert(this.endNode = template_js_1.createMarker());\n  }\n  insertAfterPart(ref) {\n    ref.__insert(this.startNode = template_js_1.createMarker());\n    this.endNode = ref.endNode;\n    ref.endNode = this.startNode;\n  }\n  setValue(value) {\n    this.__pendingValue = value;\n  }\n  commit() {\n    if (this.startNode.parentNode === null) {\n      return;\n    }\n    while (directive_js_1.isDirective(this.__pendingValue)) {\n      const directive = this.__pendingValue;\n      this.__pendingValue = part_js_1.noChange;\n      directive(this);\n    }\n    const value = this.__pendingValue;\n    if (value === part_js_1.noChange) {\n      return;\n    }\n    if (exports.isPrimitive(value)) {\n      if (value !== this.value) {\n        this.__commitText(value);\n      }\n    } else if (value instanceof template_result_js_1.TemplateResult) {\n      this.__commitTemplateResult(value);\n    } else if (value instanceof Node) {\n      this.__commitNode(value);\n    } else if (exports.isIterable(value)) {\n      this.__commitIterable(value);\n    } else if (value === part_js_1.nothing) {\n      this.value = part_js_1.nothing;\n      this.clear();\n    } else {\n      this.__commitText(value);\n    }\n  }\n  __insert(node) {\n    this.endNode.parentNode.insertBefore(node, this.endNode);\n  }\n  __commitNode(value) {\n    if (this.value === value) {\n      return;\n    }\n    this.clear();\n    this.__insert(value);\n    this.value = value;\n  }\n  __commitText(value) {\n    const node = this.startNode.nextSibling;\n    value = value == null ? '' : value;\n    const valueAsString = typeof value === 'string' ? value : String(value);\n    if (node === this.endNode.previousSibling && node.nodeType === 3) {\n      node.data = valueAsString;\n    } else {\n      this.__commitNode(document.createTextNode(valueAsString));\n    }\n    this.value = value;\n  }\n  __commitTemplateResult(value) {\n    const template = this.options.templateFactory(value);\n    if (this.value instanceof template_instance_js_1.TemplateInstance && this.value.template === template) {\n      this.value.update(value.values);\n    } else {\n      const instance = new template_instance_js_1.TemplateInstance(template, value.processor, this.options);\n      const fragment = instance._clone();\n      instance.update(value.values);\n      this.__commitNode(fragment);\n      this.value = instance;\n    }\n  }\n  __commitIterable(value) {\n    if (!Array.isArray(this.value)) {\n      this.value = [];\n      this.clear();\n    }\n    const itemParts = this.value;\n    let partIndex = 0;\n    let itemPart;\n    for (const item of value) {\n      itemPart = itemParts[partIndex];\n      if (itemPart === undefined) {\n        itemPart = new NodePart(this.options);\n        itemParts.push(itemPart);\n        if (partIndex === 0) {\n          itemPart.appendIntoPart(this);\n        } else {\n          itemPart.insertAfterPart(itemParts[partIndex - 1]);\n        }\n      }\n      itemPart.setValue(item);\n      itemPart.commit();\n      partIndex++;\n    }\n    if (partIndex < itemParts.length) {\n      itemParts.length = partIndex;\n      this.clear(itemPart && itemPart.endNode);\n    }\n  }\n  clear(startNode = this.startNode) {\n    dom_js_1.removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);\n  }\n}\nexports.NodePart = NodePart;\nclass BooleanAttributePart {\n  constructor(element, name, strings) {\n    this.value = undefined;\n    this.__pendingValue = undefined;\n    if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {\n      throw new Error('Boolean attributes can only contain a single expression');\n    }\n    this.element = element;\n    this.name = name;\n    this.strings = strings;\n  }\n  setValue(value) {\n    this.__pendingValue = value;\n  }\n  commit() {\n    while (directive_js_1.isDirective(this.__pendingValue)) {\n      const directive = this.__pendingValue;\n      this.__pendingValue = part_js_1.noChange;\n      directive(this);\n    }\n    if (this.__pendingValue === part_js_1.noChange) {\n      return;\n    }\n    const value = !!this.__pendingValue;\n    if (this.value !== value) {\n      if (value) {\n        this.element.setAttribute(this.name, '');\n      } else {\n        this.element.removeAttribute(this.name);\n      }\n      this.value = value;\n    }\n    this.__pendingValue = part_js_1.noChange;\n  }\n}\nexports.BooleanAttributePart = BooleanAttributePart;\nclass PropertyCommitter extends AttributeCommitter {\n  constructor(element, name, strings) {\n    super(element, name, strings);\n    this.single = strings.length === 2 && strings[0] === '' && strings[1] === '';\n  }\n  _createPart() {\n    return new PropertyPart(this);\n  }\n  _getValue() {\n    if (this.single) {\n      return this.parts[0].value;\n    }\n    return super._getValue();\n  }\n  commit() {\n    if (this.dirty) {\n      this.dirty = false;\n      this.element[this.name] = this._getValue();\n    }\n  }\n}\nexports.PropertyCommitter = PropertyCommitter;\nclass PropertyPart extends AttributePart {}\nexports.PropertyPart = PropertyPart;\nlet eventOptionsSupported = false;\n(() => {\n  try {\n    const options = {\n      get capture() {\n        eventOptionsSupported = true;\n        return false;\n      }\n    };\n    window.addEventListener('test', options, options);\n    window.removeEventListener('test', options, options);\n  } catch (_e) {}\n})();\nclass EventPart {\n  constructor(element, eventName, eventContext) {\n    this.value = undefined;\n    this.__pendingValue = undefined;\n    this.element = element;\n    this.eventName = eventName;\n    this.eventContext = eventContext;\n    this.__boundHandleEvent = e => this.handleEvent(e);\n  }\n  setValue(value) {\n    this.__pendingValue = value;\n  }\n  commit() {\n    while (directive_js_1.isDirective(this.__pendingValue)) {\n      const directive = this.__pendingValue;\n      this.__pendingValue = part_js_1.noChange;\n      directive(this);\n    }\n    if (this.__pendingValue === part_js_1.noChange) {\n      return;\n    }\n    const newListener = this.__pendingValue;\n    const oldListener = this.value;\n    const shouldRemoveListener = newListener == null || oldListener != null && (newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive);\n    const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);\n    if (shouldRemoveListener) {\n      this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);\n    }\n    if (shouldAddListener) {\n      this.__options = getOptions(newListener);\n      this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);\n    }\n    this.value = newListener;\n    this.__pendingValue = part_js_1.noChange;\n  }\n  handleEvent(event) {\n    if (typeof this.value === 'function') {\n      this.value.call(this.eventContext || this.element, event);\n    } else {\n      this.value.handleEvent(event);\n    }\n  }\n}\nexports.EventPart = EventPart;\nconst getOptions = o => o && (eventOptionsSupported ? {\n  capture: o.capture,\n  passive: o.passive,\n  once: o.once\n} : o.capture);\n"}