{"contents":"exports.__esModule = true;\nvar hmrCache_1 = __fusereq(33);\nfunction createHookClass(elementName, originalImpl) {\n  return class extends originalImpl {\n    static get observedAttributes() {\n      return [];\n    }\n    connectedCallback() {\n      const Impl = hmrCache_1.getMostRecentImpl(elementName);\n      const mostRecentImpl = Impl.prototype;\n      const attributes = Impl[hmrCache_1.getSymbolAttributes(elementName)];\n      const observerOptions = {\n        childList: false,\n        attributes: true,\n        attributeOldValue: true,\n        subtree: false\n      };\n      const callback = mutationList => {\n        mutationList.forEach(mutation => {\n          if (mostRecentImpl.attributeChangedCallback && attributes && attributes.indexOf(mutation.attributeName) !== -1) {\n            mostRecentImpl.attributeChangedCallback.apply(this, [mutation.attributeName, mutation.oldValue, mutation.target.getAttribute(mutation.attributeName)]);\n          }\n        });\n      };\n      if (attributes) {\n        if (Array.isArray(attributes)) {\n          attributes.forEach(attributeName => {\n            mostRecentImpl.attributeChangedCallback.apply(this, [attributeName, null, this.getAttribute(attributeName)]);\n          });\n        } else {\n          console.warn(`observedAttributes in ${elementName} is not array, please fix`);\n        }\n      }\n      this[hmrCache_1.getSymbolObserver(elementName)] = new MutationObserver(callback);\n      this[hmrCache_1.getSymbolObserver(elementName)].observe(this, observerOptions);\n      if (mostRecentImpl.connectedCallback) {\n        mostRecentImpl.connectedCallback.apply(this, arguments);\n      }\n    }\n    disconnectedCallback() {\n      this[hmrCache_1.getSymbolObserver(elementName)].disconnect();\n      this[hmrCache_1.getSymbolObserver(elementName)] = null;\n      const mostRecentImpl = hmrCache_1.getMostRecentImpl(elementName).prototype;\n      if (mostRecentImpl.disconnectedCallback) {\n        mostRecentImpl.disconnectedCallback.apply(this, arguments);\n      }\n    }\n    adoptedCallback() {\n      const mostRecentImpl = hmrCache_1.getMostRecentImpl(elementName).prototype;\n      if (mostRecentImpl.adoptedCallback) {\n        mostRecentImpl.adoptedCallback.apply(this, arguments);\n      }\n    }\n  };\n}\nexports.createHookClass = createHookClass;\n"}