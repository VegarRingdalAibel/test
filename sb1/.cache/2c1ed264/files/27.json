{"contents":"exports.__esModule = true;\nexports.marker = `{{lit-${String(Math.random()).slice(2)}}}`;\nexports.nodeMarker = `<!--${exports.marker}-->`;\nexports.markerRegex = new RegExp(`${exports.marker}|${exports.nodeMarker}`);\nexports.boundAttributeSuffix = '$lit$';\nclass Template {\n  constructor(result, element) {\n    this.parts = [];\n    this.element = element;\n    const nodesToRemove = [];\n    const stack = [];\n    const walker = document.createTreeWalker(element.content, 133, null, false);\n    let lastPartIndex = 0;\n    let index = -1;\n    let partIndex = 0;\n    const {strings, values: {length}} = result;\n    while (partIndex < length) {\n      const node = walker.nextNode();\n      if (node === null) {\n        walker.currentNode = stack.pop();\n        continue;\n      }\n      index++;\n      if (node.nodeType === 1) {\n        if (node.hasAttributes()) {\n          const attributes = node.attributes;\n          const {length} = attributes;\n          let count = 0;\n          for (let i = 0; i < length; i++) {\n            if (endsWith(attributes[i].name, exports.boundAttributeSuffix)) {\n              count++;\n            }\n          }\n          while (count-- > 0) {\n            const stringForPart = strings[partIndex];\n            const name = exports.lastAttributeNameRegex.exec(stringForPart)[2];\n            const attributeLookupName = name.toLowerCase() + exports.boundAttributeSuffix;\n            const attributeValue = node.getAttribute(attributeLookupName);\n            node.removeAttribute(attributeLookupName);\n            const statics = attributeValue.split(exports.markerRegex);\n            this.parts.push({\n              type: 'attribute',\n              index,\n              name,\n              strings: statics\n            });\n            partIndex += statics.length - 1;\n          }\n        }\n        if (node.tagName === 'TEMPLATE') {\n          stack.push(node);\n          walker.currentNode = node.content;\n        }\n      } else if (node.nodeType === 3) {\n        const data = node.data;\n        if (data.indexOf(exports.marker) >= 0) {\n          const parent = node.parentNode;\n          const strings = data.split(exports.markerRegex);\n          const lastIndex = strings.length - 1;\n          for (let i = 0; i < lastIndex; i++) {\n            let insert;\n            let s = strings[i];\n            if (s === '') {\n              insert = exports.createMarker();\n            } else {\n              const match = exports.lastAttributeNameRegex.exec(s);\n              if (match !== null && endsWith(match[2], exports.boundAttributeSuffix)) {\n                s = s.slice(0, match.index) + match[1] + match[2].slice(0, -exports.boundAttributeSuffix.length) + match[3];\n              }\n              insert = document.createTextNode(s);\n            }\n            parent.insertBefore(insert, node);\n            this.parts.push({\n              type: 'node',\n              index: ++index\n            });\n          }\n          if (strings[lastIndex] === '') {\n            parent.insertBefore(exports.createMarker(), node);\n            nodesToRemove.push(node);\n          } else {\n            node.data = strings[lastIndex];\n          }\n          partIndex += lastIndex;\n        }\n      } else if (node.nodeType === 8) {\n        if (node.data === exports.marker) {\n          const parent = node.parentNode;\n          if (node.previousSibling === null || index === lastPartIndex) {\n            index++;\n            parent.insertBefore(exports.createMarker(), node);\n          }\n          lastPartIndex = index;\n          this.parts.push({\n            type: 'node',\n            index\n          });\n          if (node.nextSibling === null) {\n            node.data = '';\n          } else {\n            nodesToRemove.push(node);\n            index--;\n          }\n          partIndex++;\n        } else {\n          let i = -1;\n          while ((i = node.data.indexOf(exports.marker, i + 1)) !== -1) {\n            this.parts.push({\n              type: 'node',\n              index: -1\n            });\n            partIndex++;\n          }\n        }\n      }\n    }\n    for (const n of nodesToRemove) {\n      n.parentNode.removeChild(n);\n    }\n  }\n}\nexports.Template = Template;\nconst endsWith = (str, suffix) => {\n  const index = str.length - suffix.length;\n  return index >= 0 && str.slice(index) === suffix;\n};\nexports.isTemplatePartActive = part => part.index !== -1;\nexports.createMarker = () => document.createComment('');\nexports.lastAttributeNameRegex = /([ \\x09\\x0a\\x0c\\x0d])([^\\0-\\x1F\\x7F-\\x9F \"'>=/]+)([ \\x09\\x0a\\x0c\\x0d]*=[ \\x09\\x0a\\x0c\\x0d]*(?:[^ \\x09\\x0a\\x0c\\x0d\"'`<>=]*|\"[^\"]*|'[^']*))$/;\n"}