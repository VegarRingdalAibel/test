import { render } from 'lit-html';
import { getObservedAttributesSymbol, getObservedAttributesMapSymbol } from './symbols';
import { logger } from './logger';
export function customElement(elementName, extended) {
    return function reg(elementClass) {
        const observedAttributes = elementClass.observedAttributes;
        Object.defineProperty(elementClass, 'observedAttributes', {
            set: function (value) {
                elementClass.prototype[getObservedAttributesSymbol()] = value;
                return true;
            },
            get: function () {
                return elementClass.prototype[getObservedAttributesSymbol()];
            },
            configurable: true
        });
        if (Array.isArray(observedAttributes) && Array.isArray(elementClass.observedAttributes)) {
            elementClass.observedAttributes = elementClass.observedAttributes.concat(observedAttributes);
        }
        if (Array.isArray(observedAttributes) && !Array.isArray(elementClass.observedAttributes)) {
            elementClass.observedAttributes = observedAttributes;
        }
        const Base = class extends elementClass {
            constructor() {
                super();
                logger('constructor', this, super.tagName);
            }
            render(...result) {
                logger('render', this, super.tagName);
                const template = super.render.call(this, ...result);
                Promise.resolve(template).then((templates) => {
                    render(templates, this, { eventContext: this });
                    if (super.updated) {
                        requestAnimationFrame(() => {
                            super.updated();
                        });
                    }
                });
            }
            connectedCallback() {
                logger('connectedCallback', this, super.tagName);
                if (super.connectedCallback) {
                    super.connectedCallback.call(this);
                }
                this.render(this);
            }
            register(call) {
                if (this.callers) {
                    this.callers.push(call);
                }
                else {
                    this.callers = [];
                    this.callers.push(call);
                }
            }
            disconnectedCallback() {
                logger('disconnectedCallback', this, super.tagName);
                if (this.callers) {
                    this.callers.forEach((call) => call());
                }
                this.callers = [];
                if (super.disconnectedCallback) {
                    super.disconnectedCallback.call(this);
                }
            }
            attributeChangedCallback(name, oldValue, newValue) {
                logger('attributeChangedCallback', this, super.tagName);
                if (!this[getObservedAttributesMapSymbol()]) {
                    const attribute = name
                        .replace(/([a-z])([A-Z])/g, '$1-$2')
                        .replace(/\s+/g, '-')
                        .toLowerCase();
                    this[getObservedAttributesMapSymbol()] = new Map();
                    this[getObservedAttributesMapSymbol()].set(attribute, name);
                }
                const nameProp = this[getObservedAttributesMapSymbol()].get(name);
                this[nameProp] = newValue || '';
                if (super.attributeChangedCallback) {
                    super.attributeChangedCallback.call(this, name, oldValue, newValue);
                }
                if (super.valuesChanged) {
                    super.valuesChanged('attribute', name, oldValue, newValue);
                }
            }
        };
        if (!customElements.get(elementName)) {
            if (extended) {
                customElements.define(elementName, Base, extended);
            }
            else {
                customElements.define(elementName, Base);
            }
        }
        else {
            if (globalThis.hmrCache) {
                if (extended) {
                    customElements.define(elementName, Base, extended);
                }
                else {
                    customElements.define(elementName, Base);
                }
            }
        }
    };
}
//# sourceMappingURL=customElement.js.map