{"version":3,"file":"custom-elements-hmr-pollyfill.cjs.js","sources":["ES6/reflow-strategy/rerenderInnerHTML.js","ES6/polyfill/hmrCache.js","ES6/polyfill/createHookClass.js","ES6/polyfill/patch.js","ES6/polyfill/constructInstance.js","ES6/polyfill/overrideCustomElementDefine.js","ES6/polyfill/onCustomElementChange.js","ES6/polyfill/reflowStrategy.js","ES6/polyfill/createHookElementChangeListener.js","ES6/polyfill/applyPolyfill.js"],"sourcesContent":["export function rerenderInnerHTML() {\r\n    if (document.body) {\r\n        requestAnimationFrame(() => {\r\n            // re-render the whole DOM\r\n            // this will make less calls to connectedCallback/disconnectedCallback on replaced child node when created.\r\n            const oldBodyHtml = document.body.innerHTML;\r\n            document.body.innerHTML = '';\r\n            document.body.innerHTML = oldBodyHtml;\r\n        });\r\n    }\r\n}\r\n//# sourceMappingURL=rerenderInnerHTML.js.map","export function initCache() {\r\n    if (!globalThis.hmrCache) {\r\n        globalThis.hmrCache = {};\r\n        globalThis.hmrCacheSymbolAttributes = {};\r\n        globalThis.hmrCacheSymbolObserver = {};\r\n    }\r\n}\r\nexport function getMostRecentImpl(elementName) {\r\n    return globalThis.hmrCache[elementName];\r\n}\r\nexport function setMostRecentImpl(elementName, impl) {\r\n    globalThis.hmrCache[elementName] = impl;\r\n}\r\nexport function isCacheInitialized() {\r\n    return globalThis.hmrCache.initialized;\r\n}\r\nexport function setCacheAsInitialized() {\r\n    globalThis.hmrCache.initialized = true;\r\n}\r\nexport function getSymbolAttributes(elementName) {\r\n    if (!globalThis.hmrCacheSymbolAttributes[elementName]) {\r\n        globalThis.hmrCacheSymbolAttributes[elementName] = Symbol('observedAttributesArray');\r\n        return globalThis.hmrCacheSymbolAttributes[elementName];\r\n    }\r\n    else {\r\n        return globalThis.hmrCacheSymbolAttributes[elementName];\r\n    }\r\n}\r\nexport function getSymbolObserver(elementName) {\r\n    if (!globalThis.hmrCacheSymbolObserver[elementName]) {\r\n        globalThis.hmrCacheSymbolObserver[elementName] = Symbol('observedAttributesObserver');\r\n        return globalThis.hmrCacheSymbolObserver[elementName];\r\n    }\r\n    else {\r\n        return globalThis.hmrCacheSymbolObserver[elementName];\r\n    }\r\n}\r\n//# sourceMappingURL=hmrCache.js.map","import { getMostRecentImpl, getSymbolAttributes, getSymbolObserver } from './hmrCache';\r\nexport function createHookClass(elementName, originalImpl) {\r\n    return class extends originalImpl {\r\n        static get observedAttributes() {\r\n            return [];\r\n        }\r\n        connectedCallback() {\r\n            const Impl = getMostRecentImpl(elementName);\r\n            const mostRecentImpl = Impl.prototype;\r\n            const attributes = Impl[getSymbolAttributes(elementName)];\r\n            const observerOptions = {\r\n                childList: false,\r\n                attributes: true,\r\n                attributeOldValue: true,\r\n                subtree: false\r\n            };\r\n            const callback = (mutationList) => {\r\n                mutationList.forEach(mutation => {\r\n                    if (mostRecentImpl.attributeChangedCallback &&\r\n                        attributes &&\r\n                        attributes.indexOf(mutation.attributeName) !== -1) {\r\n                        // call back\r\n                        mostRecentImpl.attributeChangedCallback.apply(this, [\r\n                            mutation.attributeName,\r\n                            mutation.oldValue,\r\n                            mutation.target.getAttribute(mutation.attributeName)\r\n                        ]);\r\n                    }\r\n                });\r\n            };\r\n            // call initial callback when class is created\r\n            if (attributes) {\r\n                if (Array.isArray(attributes)) {\r\n                    attributes.forEach(attributeName => {\r\n                        mostRecentImpl.attributeChangedCallback.apply(this, [\r\n                            attributeName,\r\n                            null,\r\n                            this.getAttribute(attributeName)\r\n                        ]);\r\n                    });\r\n                }\r\n                else {\r\n                    console.warn(`observedAttributes in ${elementName} is not array, please fix`);\r\n                }\r\n            }\r\n            // create and observe\r\n            this[getSymbolObserver(elementName)] = new MutationObserver(callback);\r\n            this[getSymbolObserver(elementName)].observe(this, observerOptions);\r\n            if (mostRecentImpl.connectedCallback) {\r\n                mostRecentImpl.connectedCallback.apply(this, arguments);\r\n            }\r\n        }\r\n        disconnectedCallback() {\r\n            // cleanup\r\n            this[getSymbolObserver(elementName)].disconnect();\r\n            this[getSymbolObserver(elementName)] = null;\r\n            const mostRecentImpl = getMostRecentImpl(elementName).prototype;\r\n            if (mostRecentImpl.disconnectedCallback) {\r\n                mostRecentImpl.disconnectedCallback.apply(this, arguments);\r\n            }\r\n        }\r\n        adoptedCallback() {\r\n            const mostRecentImpl = getMostRecentImpl(elementName).prototype;\r\n            if (mostRecentImpl.adoptedCallback) {\r\n                mostRecentImpl.adoptedCallback.apply(this, arguments);\r\n            }\r\n        }\r\n    };\r\n}\r\n//# sourceMappingURL=createHookClass.js.map","export function patch(recentImpl, targetImpl, BLACKLISTED_PATCH_METHODS) {\r\n    const ownPropertyNamesProto = Object.getOwnPropertyNames(recentImpl);\r\n    const whitelistedPrototypePropertyNamesProto = ownPropertyNamesProto.filter((propertyName) => {\r\n        return BLACKLISTED_PATCH_METHODS.indexOf(propertyName) === -1;\r\n    });\r\n    for (let i = 0; i < whitelistedPrototypePropertyNamesProto.length; i++) {\r\n        const propertyDescriptor = Object.getOwnPropertyDescriptor(recentImpl, whitelistedPrototypePropertyNamesProto[i]);\r\n        if (propertyDescriptor) {\r\n            if (propertyDescriptor.configurable) {\r\n                Object.defineProperty(targetImpl, whitelistedPrototypePropertyNamesProto[i], propertyDescriptor);\r\n            }\r\n            else {\r\n                console.warn('[custom-element-hmr-polyfill]', `${whitelistedPrototypePropertyNamesProto[i]} is not configurable, skipping`);\r\n            }\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=patch.js.map","import { patch } from './patch';\r\nexport const BLACKLISTED_PROTOTYPE_PATCH_METHODS = [\r\n/*\r\n// we dont need these anymore...\r\n'constructor',\r\n'connectedCallback',\r\n'disconnectedCallback',\r\n'adoptedCallback',\r\n'attributeChangedCallback'  */\r\n];\r\nexport const BLACKLISTED_STATIC_PATCH_METHODS = ['name', 'prototype', 'length'];\r\nexport function constructInstance(mostRecentImpl, args, newTarget) {\r\n    // Constructed instance points to outdated impl details.\r\n    // PROTO check\r\n    let check = window[mostRecentImpl.__proto__.name];\r\n    if (check) {\r\n        check = window[mostRecentImpl.__proto__.name].prototype instanceof Element;\r\n    }\r\n    if (!check) {\r\n        patch(mostRecentImpl.__proto__.prototype, newTarget.prototype, BLACKLISTED_PROTOTYPE_PATCH_METHODS);\r\n        // here we will update static variables/methods of \"__proto__\"\r\n        patch(mostRecentImpl.__proto__, newTarget, BLACKLISTED_STATIC_PATCH_METHODS);\r\n    }\r\n    // PROTOTYPE\r\n    patch(mostRecentImpl.prototype, newTarget.prototype, BLACKLISTED_PROTOTYPE_PATCH_METHODS);\r\n    // here we will update static variables/methods of class\r\n    patch(mostRecentImpl, mostRecentImpl, BLACKLISTED_STATIC_PATCH_METHODS);\r\n    const customElementInstance = Reflect.construct(mostRecentImpl, args, newTarget);\r\n    return customElementInstance;\r\n}\r\n//# sourceMappingURL=constructInstance.js.map","import { setMostRecentImpl, isCacheInitialized, setCacheAsInitialized, getMostRecentImpl, getSymbolAttributes } from './hmrCache';\r\nimport { createHookClass } from './createHookClass';\r\nimport { constructInstance } from './constructInstance';\r\nexport function overrideCustomElementDefine() {\r\n    if (!isCacheInitialized()) {\r\n        // make sure the override happens only once\r\n        setCacheAsInitialized();\r\n        const originalDefineFn = CustomElementRegistry.prototype.define;\r\n        CustomElementRegistry.prototype.define = function (elementName, impl, options) {\r\n            const registeredCustomElement = customElements.get(elementName);\r\n            // save and clear attribute so we are in control\r\n            impl[getSymbolAttributes(elementName)] = impl.observedAttributes;\r\n            // update cache before proxy since we need it in the createHookClass\r\n            // this will only be a issue when bundle is loaded after body\r\n            setMostRecentImpl(elementName, impl);\r\n            if (!registeredCustomElement) {\r\n                const hookClass = new Proxy(createHookClass(elementName, impl), {\r\n                    construct: function (element, args, newTarget) {\r\n                        const mostRecentImpl = getMostRecentImpl(elementName);\r\n                        return constructInstance(mostRecentImpl, args, newTarget);\r\n                    }\r\n                });\r\n                originalDefineFn.apply(this, [elementName, hookClass, options]);\r\n            }\r\n            else {\r\n                const onCustomElementChange = globalThis.hmrCache.onCustomElementChange;\r\n                if (onCustomElementChange && typeof onCustomElementChange === 'function') {\r\n                    onCustomElementChange(elementName, impl, options);\r\n                }\r\n            }\r\n        };\r\n    }\r\n}\r\n//# sourceMappingURL=overrideCustomElementDefine.js.map","import { initCache } from './hmrCache';\r\nexport const onCustomElementChange = (changeListener) => {\r\n    initCache();\r\n    if (!globalThis.hmrCache.onCustomElementChange) {\r\n        globalThis.hmrCache.onCustomElementChange = changeListener;\r\n    }\r\n};\r\n//# sourceMappingURL=onCustomElementChange.js.map","export var ReflowStrategy;\r\n(function (ReflowStrategy) {\r\n    ReflowStrategy[\"RERENDER_INNER_HTML\"] = \"rerenderInnnerHTML\";\r\n    ReflowStrategy[\"NONE\"] = \"none\";\r\n})(ReflowStrategy || (ReflowStrategy = {}));\r\n//# sourceMappingURL=reflowStrategy.js.map","import { ReflowStrategy } from './reflowStrategy';\r\nimport { rerenderInnerHTML } from '../reflow-strategy/rerenderInnerHTML';\r\nexport const createHookElementChangeListener = (reflowStrategy = ReflowStrategy.RERENDER_INNER_HTML, reflowDelayMs = 250, onCustomElementChangeListener) => {\r\n    let timer;\r\n    let elementsChanged = [];\r\n    if (!onCustomElementChangeListener) {\r\n        onCustomElementChangeListener = () => { };\r\n    }\r\n    return (elementName, impl, options) => {\r\n        onCustomElementChangeListener(elementName, impl, options);\r\n        if (reflowStrategy && reflowStrategy === ReflowStrategy.RERENDER_INNER_HTML) {\r\n            elementsChanged.push(elementName);\r\n            clearTimeout(timer);\r\n            timer = setTimeout(() => {\r\n                rerenderInnerHTML();\r\n                elementsChanged = [];\r\n            }, reflowDelayMs);\r\n        }\r\n    };\r\n};\r\n//# sourceMappingURL=createHookElementChangeListener.js.map","import { initCache } from './hmrCache';\r\nimport { overrideCustomElementDefine } from './overrideCustomElementDefine';\r\nimport { onCustomElementChange } from './onCustomElementChange';\r\nimport { createHookElementChangeListener } from './createHookElementChangeListener';\r\nimport { ReflowStrategy } from './reflowStrategy';\r\nexport function applyPolyfill(reflowStrategy = ReflowStrategy.NONE, reflowDelayMs = 250, onCustomElementChangeListener) {\r\n    initCache();\r\n    overrideCustomElementDefine();\r\n    onCustomElementChange(createHookElementChangeListener(reflowStrategy, reflowDelayMs, onCustomElementChangeListener));\r\n}\r\n//# sourceMappingURL=applyPolyfill.js.map"],"names":["rerenderInnerHTML","document","body","requestAnimationFrame","oldBodyHtml","innerHTML","initCache","globalThis","hmrCache","hmrCacheSymbolAttributes","hmrCacheSymbolObserver","getMostRecentImpl","elementName","setMostRecentImpl","impl","isCacheInitialized","initialized","setCacheAsInitialized","getSymbolAttributes","Symbol","getSymbolObserver","createHookClass","originalImpl","observedAttributes","[object Object]","Impl","mostRecentImpl","prototype","attributes","Array","isArray","forEach","attributeName","attributeChangedCallback","apply","this","getAttribute","console","warn","MutationObserver","mutationList","mutation","indexOf","oldValue","target","observe","childList","attributeOldValue","subtree","connectedCallback","arguments","disconnect","disconnectedCallback","adoptedCallback","patch","recentImpl","targetImpl","BLACKLISTED_PATCH_METHODS","whitelistedPrototypePropertyNamesProto","Object","getOwnPropertyNames","filter","propertyName","i","length","propertyDescriptor","getOwnPropertyDescriptor","configurable","defineProperty","BLACKLISTED_PROTOTYPE_PATCH_METHODS","BLACKLISTED_STATIC_PATCH_METHODS","constructInstance","args","newTarget","check","window","__proto__","name","Element","Reflect","construct","overrideCustomElementDefine","originalDefineFn","CustomElementRegistry","define","options","registeredCustomElement","customElements","get","onCustomElementChange","hookClass","Proxy","element","changeListener","ReflowStrategy","createHookElementChangeListener","reflowStrategy","RERENDER_INNER_HTML","reflowDelayMs","onCustomElementChangeListener","timer","elementsChanged","push","clearTimeout","setTimeout","applyPolyfill","NONE"],"mappings":"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"}