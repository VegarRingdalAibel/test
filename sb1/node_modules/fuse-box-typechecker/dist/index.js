"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const child = require("child_process");
const path = require("path");
const interfaces_1 = require("./interfaces");
require("./register.json5");
const getPath_1 = require("./getPath");
const inspectCode_1 = require("./inspectCode");
const printResult_1 = require("./printResult");
const printSettings_1 = require("./printSettings");
const logger_1 = require("./logger");
class TypeHelperClass {
    constructor(options) {
        this.options = options;
        // get/set base path
        if (!this.options) {
            this.options = {};
        }
        this.options.basePathSetup = options.basePath; // save original path
        this.options.basePath = options.basePath
            ? path.resolve(process.cwd(), options.basePath)
            : process.cwd();
        // get name
        this.options.name = this.options.name ? this.options.name : '';
        // shorten filenames to de-clutter output?
        this.options.shortenFilenames = this.options.shortenFilenames === false ? false : true;
        // get tsconfig path and options
        if (options.tsConfig) {
            let tsconf = getPath_1.getPath(options.tsConfig, options);
            this.options.tsConfigJsonContent = require(tsconf);
        }
        else {
            // no settings, using default
            if (!this.options.tsConfigJsonContent) {
                this.options.tsConfigJsonContent = {
                    compilerOptions: {}
                };
            }
        }
        if (options.tsConfigOverride) {
            let oldConfig = this.options.tsConfigJsonContent;
            for (let att in options.tsConfigOverride) {
                if (att === 'compilerOptions') {
                    if (oldConfig.compilerOptions) {
                        for (let attCom in options.tsConfigOverride.compilerOptions) {
                            if (attCom) {
                                oldConfig.compilerOptions[attCom] = (options.tsConfigOverride).compilerOptions[attCom];
                            }
                        }
                    }
                    else {
                        oldConfig.compilerOptions = options.tsConfigOverride.compilerOptions;
                    }
                }
                else {
                    oldConfig[att] = options.tsConfigOverride[att];
                }
            }
        }
    }
    printSettings() {
        printSettings_1.printSettings(this.options);
    }
    inspectAndPrint() {
        const lastResult = inspectCode_1.inspectCode(this.options);
        return printResult_1.printResult(this.options, lastResult);
    }
    inspectOnly(oldProgram) {
        return inspectCode_1.inspectCode(this.options, oldProgram);
    }
    printOnly(errors) {
        if (!errors || (errors && !errors.oldProgram)) {
            logger_1.Logger.info(`<black><bold><bgYellow> WARNING </bgYellow></bold></black>  <yellow><bold>No old program in params, auto running inspect first</yellow></bold>`);
            return this.inspectAndPrint();
        }
        else {
            return printResult_1.printResult(this.options, errors);
        }
    }
    worker_watch(pathToWatch) {
        this.startWorker();
        this.worker.send({
            quit: false,
            type: interfaces_1.WorkerCommand.watch,
            pathToWatch: pathToWatch,
            options: this.options
        });
    }
    worker_kill() {
        if (this.worker) {
            this.worker.kill();
        }
    }
    worker_inspect() {
        if (!this.worker) {
            this.startWorker();
        }
        this.worker.send({ type: interfaces_1.WorkerCommand.inspectCode, options: this.options });
    }
    worker_PrintSettings() {
        if (!this.worker) {
            this.startWorker();
        }
        this.worker.send({ type: interfaces_1.WorkerCommand.printSettings, options: this.options });
    }
    worker_print() {
        if (!this.worker) {
            logger_1.Logger.info('<black><bold><bgYellow> WARNING </bgYellow></bold></black> <yellow>Need to inspect code before printing first<yellow>');
        }
        else {
            this.worker.send({ type: interfaces_1.WorkerCommand.printResult, options: this.options });
        }
    }
    worker_inspectAndPrint() {
        if (!this.worker) {
            this.startWorker();
        }
        this.worker.send({ type: interfaces_1.WorkerCommand.inspectCodeAndPrint, options: this.options });
    }
    startWorker() {
        // create worker fork
        this.worker = child.fork(path.join(__dirname, 'worker.js'), []);
        // listen for worker messages
        this.worker.on('message', (msg) => {
            if (msg === 'error') {
                // if error then exit
                logger_1.Logger.echo('<black><bold><bgYellow> WARNING </bgYellow></bold></black> <yellow>- error typechecker</yellow>');
                process.exit(1);
            }
            else {
                // if not error, then just kill worker
                logger_1.Logger.echo(`<black><bold><bgYellow> WARNING </bgYellow></bold></black> <yellow>`, `<yellow>Typechecker(${this.options.name}) killing worker</yellow>`);
                this.worker_kill();
            }
        });
    }
}
exports.TypeHelperClass = TypeHelperClass;
exports.TypeChecker = (options) => {
    return new TypeHelperClass(options);
};
function pluginTypeChecker(opts) {
    return (ctx) => {
        ctx.ict.on('complete', (props) => {
            // initial run
            if (opts) {
                opts.isPlugin = true;
                /*
                    Disabled so alpha for v3 wont break, ctx going away
                    opts.homeDir = props.ctx.config.homeDir;
               */
            }
            else {
                opts = { isPlugin: true };
            }
            if (!opts.tsConfig && !opts.tsConfigJsonContent) {
                /*
                    Disabled so alpha for v3 wont break
                    opts.tsConfigJsonContent = props.ctx.tsConfig && {
                    compilerOptions: props.ctx.tsConfig.jsonCompilerOptions
                }; */
                if (opts.tsConfigJsonContentPrint) {
                    console.log(JSON.stringify(opts.tsConfigJsonContent));
                }
            }
            ctx.typeChecker = exports.TypeChecker(opts);
            if (ctx.config.env.NODE_ENV === 'production') {
                logger_1.Logger.info(`Typechecker (${opts.name ? opts.name : 'no-name'}):`, `inspecting code, please wait...`);
                ctx.typeChecker.inspectAndPrint();
            }
            else {
                // only print text if not production run
                logger_1.Logger.info(`Typechecker (${opts.name ? opts.name : 'no-name'}):`, `Starting thread. Will print status soon, please wait...`);
                if (opts.printFirstRun) {
                    ctx.typeChecker.worker_PrintSettings();
                    ctx.typeChecker.inspectAndPrint();
                }
                if (opts.dev_print) {
                    ctx.typeChecker.inspectAndPrint();
                }
                else {
                    ctx.typeChecker.worker_inspectAndPrint(); // do 1 check so it uses less time next time, we do not print by default
                }
            }
            return props;
        });
        ctx.ict.on('rebundle', (props) => {
            logger_1.Logger.info(`Typechecker (${opts.name ? opts.name : 'no-name'}):`, `Calling thread for new report, please wait...`);
            ctx.typeChecker.worker_inspectAndPrint();
            return props;
        });
    };
}
exports.pluginTypeChecker = pluginTypeChecker;
//# sourceMappingURL=index.js.map